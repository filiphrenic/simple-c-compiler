package hr.fer.zemris.ppj.lexical;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.HashMap;
import java.util.List;

import hr.fer.zemris.ppj.automaton.Automaton;
import hr.fer.zemris.ppj.automaton.AutomatonHandler;
import hr.fer.zemris.ppj.stream.Streamer;

/**
 * This class performs lexical analysis of the given input stream. It uses
 * automatons that were generated by GLA class.
 * 
 * @author fhrenic
 */
public class Lex {

    private String input;
    private OutputStream output;

    private HashMap<String, List<LexRule>> states;
    private String currentState;
    private List<LexRule> currentRules;

    private int startIndex;
    private int endIndex;
    private int lastIndex;
    private int lineNumber;

    /**
     * Creates a new Lexical Analyzer. It has a starting state. For every state
     * there is a list of rules that are considered when lex is in that state.
     * Handler has the transitions for the automatons.
     * 
     * @param startState starting state
     * @param states mapping from state to list of rules
     * @param handler has automaton transitions
     * @param output output stream that is used for printing results
     */
    public Lex(String startState, HashMap<String, List<LexRule>> states, AutomatonHandler handler,
            OutputStream output) {
        Automaton.setHandler(handler); // don't change this
        this.output = output;
        this.states = states;
        changeState(startState);

        startIndex = 0;
        endIndex = -1;
        lastIndex = -1;
        lineNumber = 1;
    }

    /**
     * Consumes symbols from input stream and performs lexical analysis.
     * 
     * @param stream input stream
     * @throws IOException
     */
    public void analyzeInput(InputStream stream) throws IOException {
        input = Streamer.readFromStream(stream);
        int len = input.length();
        LexRule lastRule = null;

        while (endIndex < len - 1) {
            boolean alive = true;
            while (alive && endIndex < len - 1) {
                alive = false;
                boolean accepted = false;
                char symbol = input.charAt(++endIndex);
                for (LexRule rule : currentRules) {
                    Automaton cur = rule.getAutomaton();
                    if (cur.isDead()) {
                        continue;
                    }
                    alive = true;
                    cur.consume(symbol);
                    if (cur.accepts() && !accepted) {
                        accepted = true;
                        lastRule = rule;
                        lastIndex = endIndex;
                    }
                }
            }

            if (lastRule == null) { // neither automaton accepted string, start again
                error();
                endIndex = startIndex++;
            } else {// it got accepted
                endIndex = lastIndex;
                lastRule.execute(this);
                if (lastRule.hasLexClass()) {
                    addLexClass(lastRule.lexClass());
                } else {
                    skip();
                }
            }
            lastRule = null;
            resetCurrentAutomatons();
        }
    }

    /**
     * Resets the automatons that belong to the current state.
     */
    private void resetCurrentAutomatons() {
        for (LexRule rule : currentRules) {
            rule.getAutomaton().reset();
        }
    }

    /**
     * Increments line number by one.
     */
    public void incrementLineNumber() {
        lineNumber++;
    }

    /**
     * Prints current lex class to the stream.
     * 
     * @param lexClass name of the lex class
     */
    public void addLexClass(String lexClass) {
        String sub = input.substring(startIndex, lastIndex + 1);
        String output = lexClass + " " + lineNumber + " " + sub + '\n';
        startIndex = lastIndex + 1;
        try {
            Streamer.writeToStream(output, this.output);
        } catch (IOException e) {
        }
    }

    /**
     * Moves the reading index back to the startIndex + toIdx
     * 
     * @param toIdx index to move
     */
    public void goBack(int toIdx) {
        resetCurrentAutomatons();
        int idx = startIndex + toIdx - 1;
        endIndex = idx;
        lastIndex = idx;
        char[] feed = input.substring(startIndex, lastIndex + 1).toCharArray();
        for (LexRule rule : currentRules) {
            for (char symbol : feed)
                rule.getAutomaton().consume(symbol);
        }

    }

    /**
     * Changes the state to the given state.
     * 
     * @param state new state
     */
    public void changeState(String state) {
        currentState = state;
        currentRules = states.get(currentState);
        resetCurrentAutomatons();
    }

    /**
     * Skips current input.
     */
    public void skip() {
        startIndex = endIndex + 1;
    }

    /**
     * This is called when an error occurs.
     */
    private void error() {
        //int leftBound = Math.max(0, startIndex - 4);
        //int rightBound = Math.min(startIndex + 4, input.length());
        //System.err.println("Error at " + input.substring(leftBound, rightBound));
        //System.err.println("Error <" + input.charAt(endIndex - 1) + ">");
    }

}
